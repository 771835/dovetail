# Advanced

> _**Translated by AI, please check for accuracy**_

## Ternary Operator

The ternary operator in dovetail language supports both traditional style and Python style:

    func main() {
        print("Hello" + "Alex" if true else "Steve")
    }

    func main() {
        print("Hello" +  true ? "Alex" : "Steve")
    }

## Functions

There are many functions in dovetail language, which are divided into `built-in functions` and `ordinary functions` **(
the following functions refer to functions defined by dovetail language, not `mcfunction`)**

### Built-in Functions

Built-in functions are implemented by the standard library or backend. For example, the `print` function is a built-in
function, and `print` actually calls the tellraw_text function.
See [dfp-300 Built-in Functions](../../proposals/DFP-300.md)
and [dfp-301 Backend Built-in Functions](../../proposals/DFP-301.md) for specific function lists.

### Ordinary Functions

Functions defined using the `func` or `method` keywords are ordinary functions.

## Annotations

Annotations are used for function definitions, allowing the compiler to determine which functions will generate
instructions and calls after compilation, such as the `init` and `tick` annotations:

    @init
    func main() {
        print("Hello Minecraft")
    }

## Classes

In dovetail language, classes are user-defined data structures used to encapsulate data and related operations.

### Definition

Use the `class` keyword to define a class. The class body can contain field declarations and method definitions:

    class ClassName {
        // Field declaration
        Type fieldName;
        
        // Method definition
        method methodName(parameterList) -> returnType {
            // Method body
        }
    }

### Constructor

Each class should have a constructor `__init__` for initializing object fields. In dovetail, the first parameter of
methods is a reference to the object itself, and constructors do not return any value:

    class Student {
        string name;
        int age;

        method __init__(Student self, string name, int age){
            self.name = name;
            self.age = age;
        }
    }

### Object Creation and Usage

Create object instances by following the class name with parentheses:

    func main() {
        // Create object
        Student student = Student("Alice",18);
        
        // Access fields
        print(student.name);  // Output: Alice
        
        // Modify fields
        student.age = 20;
        print(str(student.age));  // Output: 20
    }

### Method Calls

In addition to constructors, classes can define other methods. The first parameter of methods is always a reference to
the object itself:

    class Calculator {
        int result;

        method __init__(Calculator self){
            self.result = 0;
        }

        method add(Calculator self, int value){
            self.result = self.result + value;
        }

        method get_result(Calculator self) -> int {
            return self.result;
        }
    }

    @init
    func main() {
        Calculator calc = Calculator();
        calc.add(calc, 10);
        calc.add(calc, 5);
        print(str(calc.get_result(calc)));  // Output: 15
    }

### Class Features

- **Encapsulation**: Fields and methods are encapsulated within classes
- **Reference Semantics**: Object variables store references to objects, not the objects themselves
- **Explicit `self` parameter**: All methods need to explicitly declare the first parameter as a reference to the object
  itself
- **Constructor does not return objects**: The `__init__` constructor does not return; object creation is handled
  automatically by the runtime
- **Method name uniqueness**: Method overloading is not supported; each method name must be unique within a class
- **Method calls**: When calling methods through object instances, the object itself must be passed as the first
  parameter

### Important Notes

- **No recursion support**: The `dovetail` language does not support recursion features, so circular calls between
  classes will cause serious problems and are difficult to check at compile time
- **Uninitialized field risk**: Using uninitialized fields will lead to undefined behavior with significant risks;
  fields must be properly initialized before use
- **Reference assignment semantics**: Object instance assignment uses pass-by-reference; for example, `a = b` will make
  both `a` and `b` point to the same instance, and modifying one will affect the other
